jinx_name: arxiv
description: Interactive arXiv paper browser
inputs:
- query: ""
- limit: 10
- text: "false"

steps:
  - name: search_and_browse
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      import subprocess
      import urllib.request
      import urllib.parse
      import xml.etree.ElementTree as ET
      import textwrap

      def get_terminal_size():
          try:
              size = os.get_terminal_size()
              return size.columns, size.lines
          except:
              return 80, 24

      query = context.get('query', '')
      limit_raw = context.get('limit', 10)
      text_only = context.get('text', '').lower() in ('true', '1', 'yes')

      # Handle case where multi-word query gets split
      try:
          limit = int(limit_raw)
      except (ValueError, TypeError):
          if limit_raw and query:
              query = f"{query} {limit_raw}"
          limit = 10

      if not query:
          context['output'] = "Usage: /arxiv <query> [limit=N] [text=true]\n\nSearches arXiv. Add text=true for plain output."
      else:
          base_url = "http://export.arxiv.org/api/query"
          params = {
              "search_query": f"all:{query}",
              "start": 0,
              "max_results": limit,
              "sortBy": "relevance",
              "sortOrder": "descending"
          }

          url = f"{base_url}?{urllib.parse.urlencode(params)}"

          try:
              with urllib.request.urlopen(url, timeout=30) as response:
                  data = response.read().decode('utf-8')

              root = ET.fromstring(data)
              ns = {'atom': 'http://www.w3.org/2005/Atom'}
              entries = root.findall('atom:entry', ns)

              if not entries:
                  context['output'] = f"No papers found for: {query}"
              elif text_only:
                  results = []
                  for i, entry in enumerate(entries, 1):
                      title = entry.find('atom:title', ns).text.strip().replace('\n', ' ')
                      summary = entry.find('atom:summary', ns).text.strip()[:300] + '...'
                      published = entry.find('atom:published', ns).text[:10]
                      authors = [a.find('atom:name', ns).text for a in entry.findall('atom:author', ns)]
                      author_str = ', '.join(authors[:3])
                      if len(authors) > 3:
                          author_str += ' et al.'
                      link = entry.find('atom:id', ns).text

                      results.append(f"{i}. {title}")
                      results.append(f"   Authors: {author_str}")
                      results.append(f"   Published: {published}")
                      results.append(f"   Abstract: {summary}")
                      results.append(f"   URL: {link}")
                      results.append("")

                  context['output'] = f"Found {len(entries)} papers on arXiv:\n\n" + "\n".join(results)
              else:
                  papers = []
                  for entry in entries:
                      title = entry.find('atom:title', ns).text.strip().replace('\n', ' ')
                      abstract = entry.find('atom:summary', ns).text.strip()
                      published = entry.find('atom:published', ns).text[:10]
                      authors = [a.find('atom:name', ns).text for a in entry.findall('atom:author', ns)]
                      arxiv_id = entry.find('atom:id', ns).text

                      # Extract arxiv ID for incognide
                      aid = arxiv_id.split('/')[-1]

                      pdf_link = arxiv_id.replace('/abs/', '/pdf/') + '.pdf'

                      papers.append({
                          'title': title,
                          'authors': authors,
                          'first_author': authors[0].split()[-1] if authors else '',  # Last name
                          'abstract': abstract,
                          'published': published,
                          'url': arxiv_id,
                          'aid': aid,
                          'pdf': pdf_link
                      })

                  # Sorting and filtering
                  sort_key = 'relevance'
                  all_papers = papers[:]  # Keep original for filter reset
                  filter_year = None
                  filter_author = None

                  width, height = get_terminal_size()
                  selected = 0
                  scroll = 0
                  list_height = height - 6
                  mode = 'list'
                  detail_scroll = 0
                  input_mode = None  # 'year' or 'author'
                  input_buffer = ''

                  fd = sys.stdin.fileno()
                  old_settings = termios.tcgetattr(fd)

                  def apply_filters(papers, year=None, author=None):
                      result = papers
                      if year:
                          result = [p for p in result if p['published'].startswith(year)]
                      if author:
                          author_lower = author.lower()
                          result = [p for p in result if any(author_lower in a.lower() for a in p['authors'])]
                      return result

                  def sort_papers(papers, key, reverse=True):
                      if key == 'date':
                          return sorted(papers, key=lambda p: p['published'], reverse=reverse)
                      elif key == 'author':
                          return sorted(papers, key=lambda p: p['first_author'].lower(), reverse=not reverse)
                      elif key == 'title':
                          return sorted(papers, key=lambda p: p['title'].lower(), reverse=not reverse)
                      return papers  # relevance = original order

                  try:
                      tty.setcbreak(fd)
                      sys.stdout.write('\033[?25l')
                      sys.stdout.write('\033[2J\033[H')

                      while True:
                          width, height = get_terminal_size()
                          list_height = height - 6

                          if mode == 'list':
                              if selected < scroll:
                                  scroll = selected
                              elif selected >= scroll + list_height:
                                  scroll = selected - list_height + 1

                          sys.stdout.write('\033[H')

                          # Header
                          if mode == 'list':
                              filter_info = []
                              if filter_year:
                                  filter_info.append(f"year:{filter_year}")
                              if filter_author:
                                  filter_info.append(f"author:{filter_author}")
                              filter_str = ' '.join(filter_info)
                              if filter_str:
                                  header = f" ARXIV: '{query}' ({len(papers)}/{len(all_papers)}) [{sort_key}] {filter_str} "
                              else:
                                  header = f" ARXIV: '{query}' ({len(papers)} papers) [sort:{sort_key}] "
                          elif input_mode:
                              header = f" FILTER BY {input_mode.upper()}: {input_buffer}_ "
                          else:
                              header = f" {papers[selected]['title'][:width-4]} "
                          sys.stdout.write(f'\033[45;37;1m{header.ljust(width)}\033[0m\n')

                          if mode == 'list':
                              # Column headers
                              date_w = 12
                              auth_w = 20
                              title_w = width - date_w - auth_w - 6
                              col_header = f" {'DATE':<{date_w}} {'AUTHOR':<{auth_w}} {'TITLE':<{title_w}}"
                              sys.stdout.write(f'\033[90m{col_header[:width]}\033[0m\n')
                              sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')

                              for i in range(list_height):
                                  idx = scroll + i
                                  sys.stdout.write(f'\033[{4+i};1H\033[K')
                                  if idx >= len(papers):
                                      continue

                                  p = papers[idx]
                                  date = p['published']
                                  auth = p['first_author'][:auth_w-1]
                                  title = p['title'][:title_w-1]

                                  line = f" {date:<{date_w}} {auth:<{auth_w}} {title}"
                                  line = line[:width-1]

                                  if idx == selected:
                                      sys.stdout.write(f'\033[47;30;1m>{line.ljust(width-1)}\033[0m')
                                  else:
                                      sys.stdout.write(f' {line}')

                              sys.stdout.write(f'\033[{height-1};1H\033[K\033[90m{"─" * width}\033[0m')
                              p = papers[selected]
                              auth_full = ', '.join(p['authors'][:3])
                              if len(p['authors']) > 3:
                                  auth_full += ' et al.'
                              sys.stdout.write(f'\033[{height};1H\033[K\033[45;37m j/k:Nav Enter:View o/i/p:Open  1-3:Sort y:Year a:Author c:Clear  q:Quit [{selected+1}/{len(papers)}] \033[0m')

                          else:  # detail mode
                              sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')
                              p = papers[selected]
                              lines = []
                              lines.append(f"\033[1mTitle:\033[0m {p['title']}")
                              lines.append("")
                              lines.append(f"\033[1mAuthors:\033[0m {', '.join(p['authors'])}")
                              lines.append(f"\033[1mPublished:\033[0m {p['published']}")
                              lines.append(f"\033[1mURL:\033[0m {p['url']}")
                              lines.append(f"\033[1mPDF:\033[0m {p['pdf']}")
                              lines.append("")
                              lines.append("\033[1mAbstract:\033[0m")
                              wrapped = textwrap.wrap(p['abstract'], width=width-4)
                              lines.extend(wrapped)

                              for i in range(list_height + 1):
                                  idx = detail_scroll + i
                                  sys.stdout.write(f'\033[{3+i};1H\033[K')
                                  if idx < len(lines):
                                      sys.stdout.write(f'  {lines[idx][:width-4]}')

                              sys.stdout.write(f'\033[{height-1};1H\033[K\033[90m{"─" * width}\033[0m')
                              sys.stdout.write(f'\033[{height};1H\033[K\033[45;37m j/k:Scroll  b:Back  o:Browser  i:Incognide  p:PDF  q:Quit \033[0m')

                          sys.stdout.flush()

                          c = sys.stdin.read(1)

                          # Handle input mode (for filters)
                          if input_mode:
                              if c in ('\r', '\n'):
                                  # Apply filter
                                  if input_mode == 'year' and input_buffer:
                                      filter_year = input_buffer
                                  elif input_mode == 'author' and input_buffer:
                                      filter_author = input_buffer
                                  papers = apply_filters(all_papers, filter_year, filter_author)
                                  selected = 0
                                  scroll = 0
                                  input_mode = None
                                  input_buffer = ''
                                  sys.stdout.write('\033[2J\033[H')
                              elif c == '\x1b':
                                  # Cancel input
                                  input_mode = None
                                  input_buffer = ''
                                  sys.stdout.write('\033[2J\033[H')
                              elif c == '\x7f' or c == '\b':
                                  # Backspace
                                  input_buffer = input_buffer[:-1]
                              elif c.isprintable():
                                  input_buffer += c
                              continue

                          if c == '\x1b':
                              c2 = sys.stdin.read(1)
                              if c2 == '[':
                                  c3 = sys.stdin.read(1)
                                  if c3 == 'A':
                                      if mode == 'list' and selected > 0:
                                          selected -= 1
                                      elif mode == 'detail' and detail_scroll > 0:
                                          detail_scroll -= 1
                                  elif c3 == 'B':
                                      if mode == 'list' and selected < len(papers) - 1:
                                          selected += 1
                                      elif mode == 'detail':
                                          detail_scroll += 1
                              else:
                                  if mode == 'detail':
                                      mode = 'list'
                                      sys.stdout.write('\033[2J\033[H')
                                  else:
                                      context['output'] = "Cancelled."
                                      break
                              continue

                          if c == 'q' or c == '\x03':
                              context['output'] = f"Searched: {query} ({len(papers)} results)"
                              break
                          elif c == 'k':
                              if mode == 'list' and selected > 0:
                                  selected -= 1
                              elif mode == 'detail' and detail_scroll > 0:
                                  detail_scroll -= 1
                          elif c == 'j':
                              if mode == 'list' and selected < len(papers) - 1:
                                  selected += 1
                              elif mode == 'detail':
                                  detail_scroll += 1
                          elif c in ('\r', '\n') and mode == 'list':
                              mode = 'detail'
                              detail_scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          elif c == 'b' and mode == 'detail':
                              mode = 'list'
                              sys.stdout.write('\033[2J\033[H')
                          elif c == 'o':
                              p = papers[selected]
                              try:
                                  subprocess.Popen(['xdg-open', p['url']],
                                                   stdout=subprocess.DEVNULL,
                                                   stderr=subprocess.DEVNULL)
                              except:
                                  pass
                          elif c == 'i':
                              # Open in incognide
                              p = papers[selected]
                              try:
                                  subprocess.Popen(['incognide', p['url']],
                                                   stdout=subprocess.DEVNULL,
                                                   stderr=subprocess.DEVNULL)
                              except:
                                  # Fallback: try opening incognide with the URL
                                  try:
                                      subprocess.Popen(['incognide', '--url', p['url']],
                                                       stdout=subprocess.DEVNULL,
                                                       stderr=subprocess.DEVNULL)
                                  except:
                                      pass
                          elif c == 'p':
                              p = papers[selected]
                              try:
                                  subprocess.Popen(['xdg-open', p['pdf']],
                                                   stdout=subprocess.DEVNULL,
                                                   stderr=subprocess.DEVNULL)
                              except:
                                  pass
                          # Filter keys
                          elif c == 'y' and mode == 'list':
                              input_mode = 'year'
                              input_buffer = ''
                          elif c == 'a' and mode == 'list':
                              input_mode = 'author'
                              input_buffer = ''
                          elif c == 'c' and mode == 'list':
                              # Clear filters
                              filter_year = None
                              filter_author = None
                              papers = all_papers[:]
                              selected = 0
                              scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          # Sorting keys
                          elif c == '1':
                              sort_key = 'date'
                              papers = sort_papers(papers, 'date', True)
                              selected = 0
                              scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          elif c == '2':
                              sort_key = 'author'
                              papers = sort_papers(papers, 'author', False)
                              selected = 0
                              scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          elif c == '3':
                              sort_key = 'title'
                              papers = sort_papers(papers, 'title', False)
                              selected = 0
                              scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          elif c == '0':
                              # Re-fetch to restore original relevance order
                              sort_key = 'relevance'
                              papers_orig = []
                              for entry in entries:
                                  title = entry.find('atom:title', ns).text.strip().replace('\n', ' ')
                                  abstract = entry.find('atom:summary', ns).text.strip()
                                  published = entry.find('atom:published', ns).text[:10]
                                  authors = [a.find('atom:name', ns).text for a in entry.findall('atom:author', ns)]
                                  arxiv_id = entry.find('atom:id', ns).text
                                  aid = arxiv_id.split('/')[-1]
                                  pdf_link = arxiv_id.replace('/abs/', '/pdf/') + '.pdf'
                                  papers_orig.append({
                                      'title': title,
                                      'authors': authors,
                                      'first_author': authors[0].split()[-1] if authors else '',
                                      'abstract': abstract,
                                      'published': published,
                                      'url': arxiv_id,
                                      'aid': aid,
                                      'pdf': pdf_link
                                  })
                              papers = papers_orig
                              selected = 0
                              scroll = 0
                              sys.stdout.write('\033[2J\033[H')

                  finally:
                      termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                      sys.stdout.write('\033[?25h')
                      sys.stdout.write('\033[2J\033[H')
                      sys.stdout.flush()

          except Exception as e:
              import traceback
              context['output'] = f"arXiv error: {e}\n{traceback.format_exc()}"

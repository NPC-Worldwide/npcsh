jinx_name: "scherzo"
description: "Audio creation studio TUI - generate speech and audio with TTS engine controls"
inputs:
  - text: null
  - engine: null
  - voice: null
  - output_path: null
  - speed: null
steps:
  - name: "scherzo_tui"
    engine: "python"
    code: |
      import os
      import sys
      try:
          import tty
          import termios
      except ImportError:
          tty = None
          termios = None
      import select
      from datetime import datetime

      from npcpy.gen.audio_gen import text_to_speech, get_available_engines, get_available_voices

      npc = context.get('npc')
      if isinstance(npc, str):
          npc = None

      # ========== State ==========
      class ScherzoState:
          def __init__(self):
              self.text = ""
              self.engine_name = ""
              self.voice = ""
              self.output_path = ""
              self.speed = 1.0
              # UI state
              self.params = ['text', 'engine', 'voice', 'speed', 'output']
              self.sel = 0
              self.scroll = 0
              self.mode = 'params'  # params, editing, gallery, generating
              self.edit_buf = ""
              self.edit_cursor = 0
              self.status = "Ready"
              self.gallery = []  # [{"path": str, "text": str, "timestamp": str}]
              self.gallery_sel = 0
              self.gallery_scroll = 0

      ui = ScherzoState()

      # Load from context
      ui.text = str(context.get('text') or '')
      ui.engine_name = str(context.get('engine') or os.getenv('NPCSH_TTS_ENGINE', 'kokoro'))
      ui.voice = str(context.get('voice') or os.getenv('NPCSH_TTS_VOICE', ''))
      try:
          ui.speed = float(context.get('speed') or 1.0)
      except:
          pass
      ui.output_path = str(context.get('output_path') or '')

      # Set default voice for engine if none specified
      if not ui.voice:
          defaults = {'kokoro': 'af_heart', 'qwen3': 'ryan', 'elevenlabs': 'rachel',
                      'openai': 'alloy', 'gemini': 'Puck', 'gtts': 'en'}
          ui.voice = defaults.get(ui.engine_name, 'default')

      # Load existing gallery
      audio_dir = os.path.expanduser("~/.npcsh/audio/")
      if os.path.isdir(audio_dir):
          for f in sorted(os.listdir(audio_dir), reverse=True)[:50]:
              if f.lower().endswith(('.wav', '.mp3', '.ogg')):
                  ui.gallery.append({"path": os.path.join(audio_dir, f), "text": "", "timestamp": f})

      def get_size():
          try:
              s = os.get_terminal_size()
              return s.columns, s.lines
          except:
              return 80, 24

      def get_param_value(idx):
          p = ui.params[idx]
          if p == 'text': return ui.text
          if p == 'engine': return ui.engine_name or '(kokoro)'
          if p == 'voice': return ui.voice or '(default)'
          if p == 'speed': return str(ui.speed)
          if p == 'output': return ui.output_path or '(auto)'
          return ''

      def set_param_value(idx, val):
          p = ui.params[idx]
          if p == 'text': ui.text = val
          elif p == 'engine': ui.engine_name = val
          elif p == 'voice': ui.voice = val
          elif p == 'speed':
              try: ui.speed = max(0.1, min(5.0, float(val)))
              except: pass
          elif p == 'output': ui.output_path = val

      def generate_audio():
          ui.mode = 'generating'
          ui.status = "Generating..."
          render_screen()

          if not ui.text:
              ui.status = "Error: No text provided"
              ui.mode = 'params'
              return

          try:
              # Determine output format based on engine
              if ui.engine_name in ('elevenlabs', 'gtts'):
                  ext = '.mp3'
              else:
                  ext = '.wav'

              audio_bytes = text_to_speech(
                  ui.text,
                  engine=ui.engine_name or 'kokoro',
                  voice=ui.voice or None,
              )

              if ui.output_path and ui.output_path.strip():
                  out_file = os.path.expanduser(ui.output_path)
                  # Ensure correct extension
                  base, existing_ext = os.path.splitext(out_file)
                  if not existing_ext:
                      out_file = base + ext
              else:
                  os.makedirs(audio_dir, exist_ok=True)
                  out_file = os.path.join(audio_dir, "scherzo_" + datetime.now().strftime('%Y%m%d_%H%M%S') + ext)

              # Ensure parent directory exists
              os.makedirs(os.path.dirname(out_file) or '.', exist_ok=True)
              with open(out_file, 'wb') as f:
                  f.write(audio_bytes)

              ui.gallery.insert(0, {"path": out_file, "text": ui.text, "timestamp": os.path.basename(out_file)})
              ui.status = "Generated: " + os.path.basename(out_file) + " (" + str(len(audio_bytes)) + " bytes)"
          except Exception as e:
              ui.status = "Error: " + str(e)[:60]

          ui.mode = 'params'

      # ========== Rendering ==========
      def render_screen():
          width, height = get_size()
          out = []
          out.append("\033[H")

          header = " SCHERZO - Audio Creation Studio "
          out.append("\033[1;1H\033[7;1m" + header.ljust(width) + "\033[0m")

          if ui.mode in ('params', 'editing', 'generating'):
              out.append("\033[3;1H\033[36;1m Parameters \033[90m" + ("-" * (width - 13)) + "\033[0m")

              for i, p in enumerate(ui.params):
                  row = 4 + i
                  out.append("\033[" + str(row) + ";1H\033[K")
                  label = p.capitalize() + ":"
                  val = get_param_value(i)

                  if ui.mode == 'editing' and i == ui.sel:
                      line = "  " + label.ljust(14) + "\033[7m " + ui.edit_buf + " \033[0m"
                  else:
                      line = "  " + label.ljust(14) + val[:width - 18]

                  if i == ui.sel and ui.mode != 'editing':
                      out.append("\033[7m>" + line + "\033[0m")
                  else:
                      out.append(" " + line)

              gallery_row = 4 + len(ui.params) + 1
              out.append("\033[" + str(gallery_row) + ";1H\033[33;1m Gallery (" + str(len(ui.gallery)) + ") \033[90m" + ("-" * (width - 20)) + "\033[0m")

              gallery_h = height - gallery_row - 4
              for i in range(max(0, gallery_h)):
                  idx = ui.gallery_scroll + i
                  row = gallery_row + 1 + i
                  out.append("\033[" + str(row) + ";1H\033[K")
                  if idx >= len(ui.gallery):
                      continue
                  g = ui.gallery[idx]
                  fname = os.path.basename(g['path'])[:width - 6]
                  out.append("  " + fname)

          elif ui.mode == 'gallery':
              out.append("\033[3;1H\033[33;1m Gallery (" + str(len(ui.gallery)) + ") \033[90m" + ("-" * (width - 20)) + "\033[0m")

              gallery_h = height - 6
              for i in range(gallery_h):
                  idx = ui.gallery_scroll + i
                  row = 4 + i
                  out.append("\033[" + str(row) + ";1H\033[K")
                  if idx >= len(ui.gallery):
                      continue
                  g = ui.gallery[idx]
                  fname = os.path.basename(g['path'])
                  if idx == ui.gallery_sel:
                      out.append("\033[7m> " + fname[:width-4] + "\033[0m")
                  else:
                      out.append("  " + fname[:width-4])

          # Status + footer
          out.append("\033[" + str(height-2) + ";1H\033[K\033[90m" + ("-" * width) + "\033[0m")
          out.append("\033[" + str(height-1) + ";1H\033[K " + ui.status[:width-2])

          if ui.mode == 'editing':
              footer = " Type value, Enter:Confirm  Esc:Cancel "
          elif ui.mode == 'gallery':
              footer = " j/k:Nav  p:Play  b:Back  q:Quit "
          elif ui.mode == 'generating':
              footer = " Generating... "
          else:
              footer = " j/k:Nav  e:Edit  Enter:Generate  g:Gallery  q:Quit "
          out.append("\033[" + str(height) + ";1H\033[K\033[7m" + footer.ljust(width) + "\033[0m")

          sys.stdout.write(''.join(out))
          sys.stdout.flush()

      # ========== Input Handling ==========
      def handle_input(c, fd):
          if ui.mode == 'editing':
              return handle_edit(c, fd)
          if ui.mode == 'gallery':
              return handle_gallery(c, fd)

          if c == '\x1b':
              if select.select([fd], [], [], 0.05)[0]:
                  c2 = os.read(fd, 1).decode('latin-1')
                  if c2 == '[':
                      c3 = os.read(fd, 1).decode('latin-1')
                      if c3 == 'A':
                          ui.sel = max(0, ui.sel - 1)
                      elif c3 == 'B':
                          ui.sel = min(len(ui.params) - 1, ui.sel + 1)
              return True

          if c == 'q':
              return False
          elif c == 'j':
              ui.sel = min(len(ui.params) - 1, ui.sel + 1)
          elif c == 'k':
              ui.sel = max(0, ui.sel - 1)
          elif c == 'e' or c in ('\r', '\n'):
              if c in ('\r', '\n') and ui.sel == 0 and ui.text:
                  generate_audio()
              else:
                  ui.mode = 'editing'
                  ui.edit_buf = get_param_value(ui.sel)
                  if ui.edit_buf in ('(kokoro)', '(default)', '(auto)'):
                      ui.edit_buf = ""
                  ui.edit_cursor = len(ui.edit_buf)
          elif c == 'g':
              ui.mode = 'gallery'
              ui.gallery_sel = 0
              ui.gallery_scroll = 0
          elif c == 'G':
              generate_audio()

          return True

      def handle_edit(c, fd):
          if c == '\x1b':
              if select.select([fd], [], [], 0.05)[0]:
                  os.read(fd, 2)
              ui.mode = 'params'
              return True

          if c in ('\r', '\n'):
              set_param_value(ui.sel, ui.edit_buf)
              ui.mode = 'params'
              return True

          if c == '\x7f' or c == '\x08':
              if ui.edit_cursor > 0:
                  ui.edit_buf = ui.edit_buf[:ui.edit_cursor-1] + ui.edit_buf[ui.edit_cursor:]
                  ui.edit_cursor -= 1
          elif c >= ' ' and c <= '~':
              ui.edit_buf = ui.edit_buf[:ui.edit_cursor] + c + ui.edit_buf[ui.edit_cursor:]
              ui.edit_cursor += 1

          return True

      def handle_gallery(c, fd):
          if c == '\x1b':
              if select.select([fd], [], [], 0.05)[0]:
                  c2 = os.read(fd, 1).decode('latin-1')
                  if c2 == '[':
                      c3 = os.read(fd, 1).decode('latin-1')
                      if c3 == 'A':
                          ui.gallery_sel = max(0, ui.gallery_sel - 1)
                      elif c3 == 'B':
                          ui.gallery_sel = min(max(0, len(ui.gallery) - 1), ui.gallery_sel + 1)
              else:
                  ui.mode = 'params'
              return True

          if c == 'q':
              return False
          elif c == 'b':
              ui.mode = 'params'
          elif c == 'j':
              ui.gallery_sel = min(max(0, len(ui.gallery) - 1), ui.gallery_sel + 1)
          elif c == 'k':
              ui.gallery_sel = max(0, ui.gallery_sel - 1)
          elif c == 'p' and ui.gallery:
              import subprocess
              path = ui.gallery[ui.gallery_sel]['path']
              try:
                  if sys.platform == 'darwin':
                      subprocess.Popen(['afplay', path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                  elif sys.platform == 'linux':
                      subprocess.Popen(['aplay', path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                  ui.status = "Playing: " + os.path.basename(path)
              except:
                  ui.status = "Could not play audio"

          # Keep gallery_scroll in range
          _, height = get_size()
          gallery_h = height - 6
          if ui.gallery_sel < ui.gallery_scroll:
              ui.gallery_scroll = ui.gallery_sel
          elif ui.gallery_sel >= ui.gallery_scroll + gallery_h:
              ui.gallery_scroll = ui.gallery_sel - gallery_h + 1

          return True

      # ========== One-shot mode ==========
      if ui.text and context.get('text'):
          # If text provided via CLI args, generate immediately
          generate_audio()
          context['output'] = ui.status
          context['messages'] = context.get('messages', [])

      # ========== Main TUI Loop ==========
      elif not sys.stdin.isatty():
          context['output'] = "Scherzo requires an interactive terminal."
      else:
          fd = sys.stdin.fileno()
          old_settings = termios.tcgetattr(fd)

          try:
              tty.setcbreak(fd)
              sys.stdout.write('\033[?25l')
              sys.stdout.write('\033[2J')
              render_screen()

              running = True
              while running:
                  c = os.read(fd, 1).decode('latin-1')
                  running = handle_input(c, fd)
                  render_screen()

          finally:
              termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
              sys.stdout.write('\033[?25h')
              sys.stdout.write('\033[2J\033[H')
              sys.stdout.flush()

          context['output'] = ui.status
          context['messages'] = context.get('messages', [])

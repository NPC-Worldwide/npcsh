jinx_name: alicanto
description: Deep research mode - multi-perspective exploration with gold insights and cliff warnings
npc: forenpc
inputs:
  - query: null
  - num_npcs: 5
  - depth: 3
  - model: null
  - provider: null
  - max_steps: 20
  - skip_research: true
  - exploration: 0.3
  - creativity: 0.5
  - format: report
  - browse: false

steps:
  - name: alicanto_research
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      from termcolor import colored

      from npcpy.llm_funcs import get_llm_response
      from npcpy.data.web import search_web
      from npcpy.npc_compiler import NPC

      npc = context.get('npc')
      team = context.get('team')
      messages = context.get('messages', [])

      # Resolve npc if it's a string (npc name) rather than NPC object
      if isinstance(npc, str) and team:
          npc = team.get(npc) if hasattr(team, 'get') else None
      elif isinstance(npc, str):
          npc = None  # Can't use string npc without team to resolve it

      # ========== TUI Helper Functions ==========
      def get_terminal_size():
          try:
              size = os.get_terminal_size()
              return size.columns, size.lines
          except:
              return 80, 24

      def research_tui_browser(result):
          """Interactive TUI browser for research results"""
          perspectives = result.get('perspectives', '').split('\n')
          insights = result.get('insights', [])
          gold = result.get('gold', [])
          cliffs = result.get('cliffs', [])
          report = result.get('report', '')

          # Build tabs
          tabs = ['Gold', 'Cliffs', 'Insights', 'Report']
          current_tab = 0

          width, height = get_terminal_size()
          selected = 0
          scroll = 0
          list_height = height - 5

          fd = sys.stdin.fileno()
          old_settings = termios.tcgetattr(fd)

          try:
              tty.setcbreak(fd)
              sys.stdout.write('\033[?25l')
              sys.stdout.write('\033[2J\033[H')

              while True:
                  width, height = get_terminal_size()
                  list_height = height - 5

                  # Get current content
                  if current_tab == 0:  # Gold
                      items = gold if gold else ['No gold insights marked']
                  elif current_tab == 1:  # Cliffs
                      items = cliffs if cliffs else ['No cliff warnings marked']
                  elif current_tab == 2:  # Insights
                      items = [i[:200] for i in insights] if insights else ['No insights yet']
                  else:  # Report
                      items = report.split('\n') if report else ['No report generated']

                  if selected >= len(items):
                      selected = max(0, len(items) - 1)

                  if selected < scroll:
                      scroll = selected
                  elif selected >= scroll + list_height:
                      scroll = selected - list_height + 1

                  sys.stdout.write('\033[H')

                  # Tab bar
                  tab_bar = " "
                  for i, tab in enumerate(tabs):
                      if i == current_tab:
                          tab_bar += f'\033[43;30;1m {tab} \033[0m '
                      else:
                          tab_bar += f'\033[90m {tab} \033[0m '
                  sys.stdout.write(f'{tab_bar.ljust(width)}\n')
                  sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')

                  # Content
                  for i in range(list_height):
                      idx = scroll + i
                      sys.stdout.write(f'\033[{3+i};1H\033[K')
                      if idx >= len(items):
                          continue

                      line = str(items[idx])[:width-2]
                      if current_tab in [0, 1, 2] and idx == selected:
                          sys.stdout.write(f'\033[47;30;1m>{line.ljust(width-2)}\033[0m')
                      else:
                          # Color gold/cliff markers
                          if '[GOLD]' in line:
                              sys.stdout.write(f'\033[33m {line}\033[0m')
                          elif '[CLIFF]' in line:
                              sys.stdout.write(f'\033[31m {line}\033[0m')
                          else:
                              sys.stdout.write(f' {line}')

                  # Status bar
                  sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                  counts = f"Gold: {len(gold)} | Cliffs: {len(cliffs)} | Insights: {len(insights)}"
                  sys.stdout.write(f'\033[{height-1};1H\033[K {counts}'.ljust(width)[:width])
                  sys.stdout.write(f'\033[{height};1H\033[K\033[43;30m h/l:Tabs j/k:Nav Enter:View q:Quit [{selected+1}/{len(items)}] \033[0m')

                  sys.stdout.flush()

                  c = sys.stdin.read(1)

                  if c == '\x1b':
                      c2 = sys.stdin.read(1)
                      if c2 == '[':
                          c3 = sys.stdin.read(1)
                          if c3 == 'A' and selected > 0:
                              selected -= 1
                          elif c3 == 'B' and selected < len(items) - 1:
                              selected += 1
                          elif c3 == 'C':  # Right
                              current_tab = (current_tab + 1) % len(tabs)
                              selected = 0
                              scroll = 0
                          elif c3 == 'D':  # Left
                              current_tab = (current_tab - 1) % len(tabs)
                              selected = 0
                              scroll = 0
                      else:
                          return
                      continue

                  if c == 'q' or c == '\x03':
                      return
                  elif c == 'k' and selected > 0:
                      selected -= 1
                  elif c == 'j' and selected < len(items) - 1:
                      selected += 1
                  elif c == 'h':
                      current_tab = (current_tab - 1) % len(tabs)
                      selected = 0
                      scroll = 0
                  elif c == 'l':
                      current_tab = (current_tab + 1) % len(tabs)
                      selected = 0
                      scroll = 0
                  elif c in ('\r', '\n') and current_tab < 3:
                      # Show full item
                      item = items[selected] if selected < len(items) else ''
                      print(f'\033[2J\033[H{item}\n\nPress any key to continue...')
                      sys.stdout.flush()
                      sys.stdin.read(1)
                      sys.stdout.write('\033[2J\033[H')

          finally:
              termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
              sys.stdout.write('\033[?25h')
              sys.stdout.write('\033[2J\033[H')
              sys.stdout.flush()

      query = context.get('query')
      num_npcs = int(context.get('num_npcs', 5))
      depth = int(context.get('depth', 3))
      max_steps = int(context.get('max_steps', 20))
      skip_research = context.get('skip_research', True)
      exploration = float(context.get('exploration', 0.3))
      creativity = float(context.get('creativity', 0.5))
      output_format = context.get('format', 'report')

      # Handle case where npc might be a string (npc name) or NPC object
      model = context.get('model') or (npc.model if npc and hasattr(npc, 'model') else 'gemini-1.5-pro')
      provider = context.get('provider') or (npc.provider if npc and hasattr(npc, 'provider') else 'gemini')

      if not query:
          context['output'] = """Usage: /alicanto <research query>

      Options:
        --num-npcs N      Number of research perspectives (default: 5)
        --depth N         Research depth (default: 3)
        --max-steps N     Maximum research steps (default: 20)
        --exploration F   Exploration factor 0-1 (default: 0.3)
        --creativity F    Creativity factor 0-1 (default: 0.5)
        --format FORMAT   Output: report|summary|full (default: report)

      Example: /alicanto What are the latest advances in quantum computing?"""
          context['messages'] = messages
          exit()

      print(f"""
       █████╗ ██╗     ██╗ ██████╗ █████╗ ███╗   ██╗████████╗ ██████╗
      ██╔══██╗██║     ██║██╔════╝██╔══██╗████╗  ██║╚══██╔══╝██╔═══██╗
      ███████║██║     ██║██║     ███████║██╔██╗ ██║   ██║   ██║   ██║
      ██╔══██║██║     ██║██║     ██╔══██║██║╚██╗██║   ██║   ██║   ██║
      ██║  ██║███████╗██║╚██████╗██║  ██║██║ ╚████║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚══════╝╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝    ╚═════╝

      Deep Research Mode
      Query: {query}
      Perspectives: {num_npcs} | Depth: {depth} | Max Steps: {max_steps}
      """)

      # Generate research perspectives
      perspectives_prompt = f"""Generate {num_npcs} distinct research perspectives for investigating: "{query}"

      For each perspective, provide:
      1. Name (a descriptive title)
      2. Approach (how this perspective would investigate)
      3. Key questions to explore

      Return as a numbered list."""

      print(colored("Generating research perspectives...", "cyan"))
      resp = get_llm_response(
          perspectives_prompt,
          model=model,
          provider=provider,
          npc=npc
      )
      perspectives = str(resp.get('response', ''))
      print(perspectives)

      # Conduct web research if not skipped
      research_findings = ""
      if not skip_research:
          print(colored("\nConducting web research...", "cyan"))
          try:
              search_results = search_web(query, n_results=5)
              if search_results:
                  research_findings = "\n\nWeb Research Findings:\n"
                  for i, result in enumerate(search_results[:5], 1):
                      title = result.get('title', 'No title')
                      snippet = result.get('snippet', result.get('body', ''))[:200]
                      research_findings += f"\n{i}. {title}\n   {snippet}...\n"
                  print(colored(f"Found {len(search_results)} sources", "green"))
          except Exception as e:
              print(colored(f"Web search error: {e}", "yellow"))

      # Multi-step exploration from each perspective
      all_insights = []
      gold_insights = []  # Key valuable findings
      cliff_warnings = []  # Potential pitfalls or caveats

      for step in range(min(depth, max_steps)):
          print(colored(f"\n--- Research Depth {step + 1}/{depth} ---", "cyan"))

          explore_prompt = f"""Research query: "{query}"

      Perspectives generated:
      {perspectives}

      {research_findings}

      Previous insights: {all_insights[-3:] if all_insights else 'None yet'}

      For depth level {step + 1}:
      1. Explore deeper implications from each perspective
      2. Identify GOLD insights (valuable, non-obvious findings) - mark with [GOLD]
      3. Identify CLIFF warnings (pitfalls, caveats, risks) - mark with [CLIFF]
      4. Connect insights across perspectives

      Exploration factor: {exploration} (higher = more diverse exploration)
      Creativity factor: {creativity} (higher = more novel connections)"""

          resp = get_llm_response(
              explore_prompt,
              model=model,
              provider=provider,
              temperature=creativity,
              npc=npc
          )

          step_insights = str(resp.get('response', ''))
          print(step_insights)

          # Extract gold and cliff markers
          if '[GOLD]' in step_insights:
              gold_insights.extend([line.strip() for line in step_insights.split('\n') if '[GOLD]' in line])
          if '[CLIFF]' in step_insights:
              cliff_warnings.extend([line.strip() for line in step_insights.split('\n') if '[CLIFF]' in line])

          all_insights.append(step_insights)

      # Generate final synthesis
      print(colored("\n--- Synthesizing Research ---", "cyan"))

      synthesis_prompt = f"""Synthesize research on: "{query}"

      All insights gathered:
      {chr(10).join(all_insights)}

      Gold insights identified:
      {chr(10).join(gold_insights) if gold_insights else 'None explicitly marked'}

      Cliff warnings identified:
      {chr(10).join(cliff_warnings) if cliff_warnings else 'None explicitly marked'}

      Generate a {output_format} that:
      1. Summarizes key findings
      2. Highlights the most valuable insights (gold)
      3. Notes important caveats and risks (cliffs)
      4. Provides actionable conclusions"""

      resp = get_llm_response(
          synthesis_prompt,
          model=model,
          provider=provider,
          npc=npc
      )

      final_report = str(resp.get('response', ''))
      print("\n" + "="*60)
      print(colored("ALICANTO RESEARCH REPORT", "green", attrs=['bold']))
      print("="*60)
      print(final_report)

      alicanto_result = {
          'query': query,
          'perspectives': perspectives,
          'insights': all_insights,
          'gold': gold_insights,
          'cliffs': cliff_warnings,
          'report': final_report
      }

      context['output'] = final_report
      context['messages'] = messages
      context['alicanto_result'] = alicanto_result

      # Launch interactive browser automatically
      if gold_insights or cliff_warnings or all_insights:
          print(colored("\nLaunching results browser...", "cyan"))
          research_tui_browser(alicanto_result)

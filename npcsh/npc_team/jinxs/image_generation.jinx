jinx_name: image_generation_jinx
description: 'Generates images based on a text prompt. Prompt must be specified to facilitate the users goal and should NOT be a verbatim replication of their request unless asked. The output name must be a path relative to the current directory. do NOT use placeholders. specify ./descriptive_image_name.png. Model must be specified if the user indicates a specific model or provider. For example, if they want gemini-2.5-flash you should specify gemini-2.5-flash as the model and gemini as the provider . if they specify gpt-image-1 you should specify gpt-image-1 as the model and openai as the provider. Only leave it the default if the user does not indicate the model preference.'
inputs:
- prompt
- output_name
- model: runwayml/stable-diffusion-v1-5
- provider: diffusers
steps:
  - engine: "python"
    code: |
      import os
      import base64
      from io import BytesIO
      from datetime import datetime
      from PIL import Image
      from npcpy.llm_funcs import gen_image
      
      image_prompt = '{{prompt}}'.strip()
      output_name = '{{output_name}}'
      model = '{{model}}'
      provider = '{{provider}}'
      
      try:
          # Generate image(s)
          images_list = gen_image(
              prompt=image_prompt,
              model=model,
              provider=provider,
              npc=npc,
              n_images=1
          )
          
          if not isinstance(images_list, list):
              images_list = [images_list] if images_list is not None else []
          
          saved_files = []
          compressed_images = []
          
          for i, image in enumerate(images_list):
              if image is None:
                  continue
              
              # Determine output filename
              if output_name:
                  if not output_name.endswith('.png'):
                      current_output_file = f"{output_name}_{i}.png" if len(images_list) > 1 else f"{output_name}.png"
                  else:
                      base_name = output_name.replace('.png', '')
                      current_output_file = f"{base_name}_{i}.png" if len(images_list) > 1 else output_name
              else:
                  os.makedirs(os.path.expanduser("~/.npcsh/images/"), exist_ok=True)
                  current_output_file = (
                      os.path.expanduser("~/.npcsh/images/")
                      + f"image_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{i}.png"
                  )
              
              # Save image to file
              image.save(current_output_file)
              saved_files.append(current_output_file)
              
              # Create compressed base64 image for HTML rendering
              img_buffer = BytesIO()
              # Resize for web display (max 800x600 while maintaining aspect ratio)
              img_copy = image.copy()
              img_copy.thumbnail((800, 600), Image.Resampling.LANCZOS)
              img_copy.save(img_buffer, format='PNG', optimize=True, quality=85)
              img_buffer.seek(0)
              
              # Convert to base64
              img_base64 = base64.b64encode(img_buffer.getvalue()).decode('utf-8')
              compressed_images.append(f"data:image/png;base64,{img_base64}")
          
          if saved_files:
              output = f"Image(s) generated and saved to: {', '.join(saved_files)}"
              # Add HTML img tags for rendering
              html_images = ""
              for img_b64 in compressed_images:
                  html_images += f'<img src="{img_b64}" style="max-width: 400px; margin: 10px;" /><br/>'
              
              output += f"\n\nGenerated Images:\n{html_images}"
          else:
              output = "No images generated."
              
      except Exception as e:
          import traceback
          traceback.print_exc()
          output = f"Error generating image: {str(e)}"
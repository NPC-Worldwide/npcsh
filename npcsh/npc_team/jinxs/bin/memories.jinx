jinx_name: memories
description: Interactive TUI for browsing and managing npcsh memories
interactive: true
inputs:
  - scope: ""
steps:
  - name: memory_browser
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      import select
      from datetime import datetime

      if not sys.stdin.isatty():
          context['output'] = "Memory browser requires an interactive terminal."

      else:
          from npcpy.memory.command_history import CommandHistory
          from npcsh.config import NPCSH_DB_PATH
          from sqlalchemy import text

          db_path = os.path.expanduser(NPCSH_DB_PATH)
          command_history = CommandHistory(db_path)

          # ========== Discover actual status values from DB ==========
          db_statuses = []
          try:
              with command_history.engine.connect() as conn:
                  rows = conn.execute(text("SELECT DISTINCT status FROM memory_lifecycle ORDER BY status"))
                  db_statuses = [r[0] for r in rows if r[0]]
          except:
              pass

          # Build tabs: All + one tab per distinct status
          tab_names = ['All'] + db_statuses
          # Build filter SQL for each tab
          tab_filters = [None]  # All = no filter
          for s in db_statuses:
              tab_filters.append(s)

          # ========== State ==========
          class MemoryState:
              def __init__(self):
                  self.tab = 0
                  self.tabs = tab_names
                  self.tab_filters = tab_filters
                  self.memories = []
                  self.selected_idx = 0
                  self.scroll_offset = 0
                  self.preview_mode = False
                  self.status_msg = ""
                  self.filters = {'npc': None, 'team': None}

          state = MemoryState()

          # ========== Helpers ==========
          def get_size():
              try:
                  s = os.get_terminal_size()
                  return s.columns, s.lines
              except:
                  return 80, 24

          def status_icon(status_val):
              """Map any status string to an icon based on substring matching."""
              if not status_val:
                  return '?'
              s = status_val.lower()
              if 'approved' in s or 'edited' in s:
                  return '\033[32m*\033[0m'
              if 'rejected' in s:
                  return '\033[31mx\033[0m'
              if 'pending' in s:
                  return '\033[33mo\033[0m'
              return '\033[90m?\033[0m'

          def status_color(status_val):
              if not status_val:
                  return '0'
              s = status_val.lower()
              if 'approved' in s or 'edited' in s:
                  return '32'
              if 'rejected' in s:
                  return '31'
              if 'pending' in s:
                  return '33'
              return '0'

          def load_memories():
              state.memories = []
              try:
                  with command_history.engine.connect() as conn:
                      sf = state.tab_filters[state.tab] if state.tab < len(state.tab_filters) else None
                      query = "SELECT id, created_at, npc, team, directory_path, initial_memory, final_memory, status FROM memory_lifecycle"
                      conditions = []
                      params = {}

                      if sf:
                          conditions.append("status = :sf")
                          params['sf'] = sf
                      if state.filters['npc']:
                          conditions.append("npc = :npc")
                          params['npc'] = state.filters['npc']
                      if state.filters['team']:
                          conditions.append("team = :team")
                          params['team'] = state.filters['team']

                      if conditions:
                          query += " WHERE " + " AND ".join(conditions)
                      query += " ORDER BY created_at DESC LIMIT 200"

                      result = conn.execute(text(query), params)
                      for row in result:
                          state.memories.append({
                              'id': row[0],
                              'created_at': row[1],
                              'npc': row[2],
                              'team': row[3],
                              'scope': row[4] or '',
                              'original': row[5],
                              'final': row[6],
                              'status': row[7]
                          })
              except Exception as e:
                  state.status_msg = "Error loading memories: " + str(e)

          def update_memory_status(memory_id, new_status, final_memory=None):
              try:
                  command_history.update_memory_status(memory_id, new_status, final_memory)
                  state.status_msg = "Memory " + str(memory_id) + " -> " + new_status
                  load_memories()
              except Exception as e:
                  state.status_msg = "Error: " + str(e)

          def format_date(dt_str):
              if not dt_str:
                  return "          "
              try:
                  if isinstance(dt_str, str):
                      dt = datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
                  else:
                      dt = dt_str
                  return dt.strftime('%m-%d %H:%M')
              except:
                  return str(dt_str)[:10]

          # ========== Rendering ==========
          def render_screen():
              width, height = get_size()
              out = []

              # Header
              header = " MEMORY BROWSER (" + str(len(state.memories)) + ") "
              out.append("\033[1;1H\033[K\033[7;1m" + header.ljust(width) + "\033[0m")

              # Tabs
              tab_str = ""
              for i, tab in enumerate(state.tabs):
                  if i == state.tab:
                      tab_str += "\033[7m [" + tab + "] \033[0m"
                  else:
                      tab_str += " [" + tab + "] "
              out.append("\033[2;1H\033[K " + tab_str)

              # Separator
              out.append("\033[3;1H\033[K\033[90m" + ("-" * width) + "\033[0m")

              if state.preview_mode and state.memories:
                  render_preview(out, width, height)
              else:
                  render_list(out, width, height)

              # Status bar
              out.append("\033[" + str(height-2) + ";1H\033[K\033[90m" + ("-" * width) + "\033[0m")
              out.append("\033[" + str(height-1) + ";1H\033[K")
              if state.status_msg:
                  out.append(" \033[33m" + state.status_msg[:width-2] + "\033[0m")

              # Footer
              if state.preview_mode:
                  footer = " Esc:Back  a:Approve  x:Reject  j/k:Prev/Next  q:Quit "
              else:
                  footer = " Tab:Filter  j/k:Nav  p:Preview  a:Approve  x:Reject  q:Quit "
              out.append("\033[" + str(height) + ";1H\033[K\033[7m" + footer.ljust(width) + "\033[0m")

              sys.stdout.write(''.join(out))
              sys.stdout.flush()

          def render_list(out, width, height):
              visible_height = height - 7
              visible = state.memories[state.scroll_offset:state.scroll_offset + visible_height]

              for i in range(visible_height):
                  row = 4 + i
                  out.append("\033[" + str(row) + ";1H\033[K")
                  idx = state.scroll_offset + i
                  if idx >= len(state.memories):
                      continue

                  mem = state.memories[idx]
                  icon = status_icon(mem['status'])
                  date_str = format_date(mem['created_at'])
                  npc_str = (mem['npc'] or '-')[:8]
                  content = (mem['final'] or mem['original'] or '')[:width-35].replace('\n', ' ')

                  line = icon + " " + date_str + " " + npc_str.ljust(9) + content

                  if idx == state.selected_idx:
                      out.append("\033[7m>" + line + "\033[0m")
                  else:
                      out.append(" " + line)

              # Scroll indicator
              if len(state.memories) > visible_height and visible_height > 0:
                  total = max(1, len(state.memories) - visible_height)
                  pct = int((state.scroll_offset / total) * 100)
                  out.append("\033[4;" + str(width-6) + "H\033[90m[" + str(pct) + "%]\033[0m")

              if not state.memories:
                  out.append("\033[5;4H\033[90mNo memories found.\033[0m")

          def render_preview(out, width, height):
              if not state.memories or state.selected_idx >= len(state.memories):
                  return

              mem = state.memories[state.selected_idx]

              row = 4
              out.append("\033[" + str(row) + ";1H\033[K\033[1m Memory #" + str(mem['id']) + "\033[0m")
              row += 1

              sc = status_color(mem['status'])
              out.append("\033[" + str(row) + ";1H\033[K Status: \033[" + sc + "m" + str(mem['status']) + "\033[0m")
              row += 1
              out.append("\033[" + str(row) + ";1H\033[K Date: " + format_date(mem['created_at']))
              row += 1
              out.append("\033[" + str(row) + ";1H\033[K NPC: " + str(mem['npc'] or '-') + "  Team: " + str(mem['team'] or '-') + "  Scope: " + str(mem['scope'] or '-')[:40])
              row += 1
              out.append("\033[" + str(row) + ";1H\033[K")
              row += 1

              out.append("\033[" + str(row) + ";1H\033[K\033[1m Content:\033[0m")
              row += 1

              content = mem['final'] or mem['original'] or '(empty)'
              content_lines = content.split('\n')
              max_lines = height - row - 3
              for line in content_lines[:max_lines]:
                  out.append("\033[" + str(row) + ";1H\033[K   " + line[:width-5])
                  row += 1

              # Clear remaining lines
              while row < height - 2:
                  out.append("\033[" + str(row) + ";1H\033[K")
                  row += 1

          # ========== Input Handling ==========
          def handle_input(c):
              if c == 'q' or c == '\x03':
                  return False

              if c == '\x1b':
                  if select.select([fd], [], [], 0.05)[0]:
                      c2 = os.read(fd, 1).decode('latin-1')
                      if c2 == '[':
                          c3 = os.read(fd, 1).decode('latin-1')
                          if c3 == 'A':
                              move_up()
                          elif c3 == 'B':
                              move_down()
                  else:
                      if state.preview_mode:
                          state.preview_mode = False
                  return True

              if c == '\t':
                  state.tab = (state.tab + 1) % len(state.tabs)
                  state.selected_idx = 0
                  state.scroll_offset = 0
                  load_memories()
                  state.status_msg = ""
              elif c == 'k':
                  move_up()
              elif c == 'j':
                  move_down()
              elif c == 'p' or c == '\r' or c == '\n':
                  if state.memories:
                      state.preview_mode = not state.preview_mode
              elif c == 'a':
                  approve_current()
              elif c == 'x':
                  reject_current()

              return True

          def move_up():
              state.selected_idx = max(0, state.selected_idx - 1)
              if state.selected_idx < state.scroll_offset:
                  state.scroll_offset = state.selected_idx
              state.status_msg = ""

          def move_down():
              _, height = get_size()
              visible_height = height - 7
              state.selected_idx = min(max(0, len(state.memories) - 1), state.selected_idx + 1)
              if state.selected_idx >= state.scroll_offset + visible_height:
                  state.scroll_offset = state.selected_idx - visible_height + 1
              state.status_msg = ""

          def approve_current():
              if state.memories and state.selected_idx < len(state.memories):
                  mem = state.memories[state.selected_idx]
                  update_memory_status(mem['id'], 'human-approved', mem.get('final') or mem.get('original'))

          def reject_current():
              if state.memories and state.selected_idx < len(state.memories):
                  mem = state.memories[state.selected_idx]
                  update_memory_status(mem['id'], 'human-rejected', mem.get('final') or mem.get('original'))

          # ========== Main Loop ==========
          load_memories()

          fd = sys.stdin.fileno()
          old_settings = termios.tcgetattr(fd)

          try:
              tty.setcbreak(fd)
              sys.stdout.write('\033[?25l')
              sys.stdout.write('\033[2J')
              render_screen()

              while True:
                  c = os.read(fd, 1).decode('latin-1')
                  if not handle_input(c):
                      break
                  render_screen()

          finally:
              termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
              sys.stdout.write('\033[?25h')
              sys.stdout.write('\033[2J\033[H')
              sys.stdout.flush()

          context['output'] = "Memory browser closed."
